# TODO

Отмечайте прогресс в колонке **DONE**: пока задача не выполнена, ставьте «✗», после завершения замените на «✓».

## Part 2 2025-09-27
| ID      | DONE | Task (Описание задачи)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Area               | Priority | Dependencies                                  |
| ------- | ---- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------ | -------- | --------------------------------------------- |
| **DX2** | ✓    | **Restructure research docs** – `docs/researches/` now stores dated research files (`<YYYY-MM-DD>-v<version>-<short-name>.md`), and `LATEST_RESEARCH.md` is a pointer to the latest entry. **AGENTS.md** references this structure so agents know where to find up-to-date research info.                                                                                                                                                                                                                                                                                                                                  | Repo/Docs          | P0       | —                                             |
| **B4**  | ✓    | **Initialize Alembic and baseline migration** – Set up Alembic for DB migrations and create the initial migration for the existing models **User**, **Meeting**, **Transcript** (including the enum `MeetingStatus`). This migration should create all tables and constraints as per SQLAlchemy models. Update configuration/docs on how to run migrations.                                                                                                                                                                                                                                                                                                                                                                   | Backend/DB         | P0       | — (models exist)                              |
| **A5**  | ✓    | **Auth: User Registration API** – Implement `POST /auth/register` endpoint to create a new user. Accept email & password, hash the password (use a secure hash, e.g. bcrypt), and store the User in DB (via UserRepository). Enforce unique email and basic validation (email format, password length). Return a success or created status (no login yet).                                                                                                                                                                                                                                                                                                                                                                    | Backend/Auth API   | P0       | B4 (DB ready)                                 |
| **A6**  | ✓    | **Auth: Login API (JWT)** – Implement `POST /auth/login` endpoint to authenticate. Verify the provided credentials against the stored user (find by email, check password hash). If valid, respond with a JSON Web Token (JWT) for session auth (include user ID/claims). Use a secret key (configure in settings/env) and a standard library (e.g. PyJWT) to generate tokens. On failure, return 401.                                                                                                                                                                                                                                                                                                                        | Backend/Auth API   | P0       | A5 (user exists)                              |
| **A7**  | ✓    | **JWT Authentication Middleware** – Implement JWT verification in FastAPI. Create a dependency (e.g. `get_current_user`) that checks the `Authorization: Bearer <token>` header, decodes the JWT, verifies signature and expiration, and loads the user from the DB. On success, attach `current_user` (User model) to the request context; on failure, return 401/403. Configure protected routes to use this dependency.                                                                                                                                                                                                                                                                                                    | Backend/Auth Core  | P1       | A6 (token issuance)                           |
| **A8**  | ✓    | **Secure & Enhance Meeting Endpoints** – **(Depends on A7)** Protect the `/api/meeting/*` routes with auth: require a valid JWT to access `/upload` and `/stream`. Modify the **`upload_audio`** handler to **persist the meeting in the database** using MeetingRepository: when a file is uploaded, create a Meeting record with `user_id = current_user.id`, filename, timestamp, status “pending”. Return the meeting ID as before. Modify **`stream_transcript`** to ensure the requesting user owns the meeting: look up the meeting by ID (MeetingRepository) and if `meeting.user_id` != current_user, return 403. This secures data access. Mark meeting status “processing” when starting transcription (optional). | Backend/API        | P1       | A7 (auth)                                     |
| **S2**  | ✗    | **Persist Transcription Results** – After audio processing, save the results to DB. In `TranscriptService.stream_transcript` (or after obtaining `MeetingProcessingResult`), use TranscriptRepository to **create Transcript entries** for each transcript segment (text + speaker and timestamp if available) in the result. Also, update the Meeting status to “completed” (MeetingRepository.update) and consider storing the final summary. *Option:* store summary in a special Transcript entry or add a `summary` field in Meeting (if needed, could be a migration). Handle error cases: if processing fails, update Meeting status to “failed”. This task ensures transcripts are persisted for later retrieval.     | Backend/Services   | P0       | A8 (meeting in DB)                            |
| **T3**  | ✗    | **Test: E2E Transcription Storage** – Add tests to verify that uploading and processing audio leads to stored results. For example, use the `/api/meeting/upload` and then simulate or call `TranscriptService.stream_transcript` with a mock client to completion. Then verify via MeetingRepository/TranscriptRepository that the Meeting status became completed and transcripts were saved. Also test authorization: ensure that accessing `/stream` with a wrong user or invalid token is forbidden.                                                                                                                                                                                                                     | Tests              | P1       | S2, A8 (functional pipeline)                  |
| **A9**  | ✗    | **API: List User Meetings** – Implement `GET /api/meeting` endpoint to return the current user’s meetings list. Use MeetingRepository.list_by_user(current_user.id) to fetch meetings, and return a brief JSON (e.g. meeting ID, filename, date, status, summary snippet if available). This allows the frontend to show a history of uploads. Require JWT auth.                                                                                                                                                                                                                                                                                                                                                              | Backend/API        | P2       | A8, S2 (needs data)                           |
| **A10** | ✗    | **API: Get Transcript Details** – Implement `GET /api/meeting/{meeting_id}` to fetch the full transcript for a completed meeting. Require auth and ownership (current_user must match the meeting’s user). Use TranscriptRepository.list_by_meeting(meeting_id) to get all transcript segments, and return them (and possibly the final summary, e.g. as a separate field). This provides a way for the frontend to retrieve past transcript content without reprocessing audio.                                                                                                                                                                                                                                              | Backend/API        | P2       | S2 (transcripts saved), A8                    |
| **F5**  | ✓    | **Frontend: Login Page** – Create a login form UI in the frontend. Allow the user to input email and password and submit to the `/auth/login` API. On success, store the JWT (e.g. in memory or localStorage) and mark the user as logged in (e.g. update app state). Handle error responses (show invalid credentials message). Ensure subsequent API requests include the JWT in `Authorization` header (e.g. configure a global fetch/axios interceptor or attach manually). This is critical so that the user can authenticate before using other features.                                                                                                                                                               | Frontend/Auth UI   | P0       | A6 (login API ready)                          |
| **F6**  | ✓    | **Frontend: Registration Page** – *(Optional)* Create a sign-up form to call `/auth/register`. Allow entering email/password, call the API to create an account, and perhaps auto-login or redirect to login on success. This feature is lower priority if accounts are managed separately, but helpful for testing the registration flow. Include basic validation (e.g. password length).                                                                                                                                                                                                                                                                                                                                   | Frontend/Auth UI   | P2       | A5 (register API)                             |
| **F7**  | ✓    | **Frontend: File Upload UI** – Implement a page or component for uploading audio files (accessible after login). This should provide a **drag-and-drop area or file picker** for a WAV file, show the file name and size, and a **upload progress bar**. When the user selects a file and submits, send it via POST to `/api/meeting/upload` (include the auth token). On response, get the `meeting_id`. Then immediately open a Server-Sent Events connection to `/api/meeting/{meeting_id}/stream` to start receiving transcript events. Handle error cases (e.g. non-WAV file rejection as 415, show a message).                                                                                                          | Frontend/Upload UI | P1       | F5 (user can log in)                          |
| **F8**  | ✓    | **Frontend: Live Transcript Display** – Implement a component to handle the SSE stream and display the transcript in real-time. As transcript `event: transcript` messages arrive, append the text to the display with proper formatting (e.g. each speaker segment on a new line, maybe prefix with speaker name or ID if provided). When an `event: summary` arrives, display the final summary (e.g. at the end or in a special section). Ensure the UI is scrollable if long, and consider an indication for “processing...” while events are coming. This will use the SSE logic from the existing SSE component (built in task F1) – integrate that to update state and re-render the transcript as data comes in.      | Frontend/SSE UI    | P1       | F7 (meeting_id from upload)                   |
| **F9**  | ✗    | **Frontend: Meetings List Page** – After transcription, allow the user to see all past meetings. Implement a page that calls `GET /api/meeting` to fetch the current user’s meetings. Display them in a list or table (show date, filename, status, maybe a snippet of summary). If a meeting is clicked, navigate to a transcript detail view. This requires the backend listing API. Only show this page to logged-in users.                                                                                                                                                                                                                                                                                                | Frontend/UI        | P2       | A9 (list API), F5                             |
| **F10** | ✗    | **Frontend: Transcript Detail View** – Implement a page to view a completed transcript (for a given meeting). On mount, call `GET /api/meeting/{meeting_id}` to fetch all transcript segments (or you could reuse the SSE stream in replay mode, but better to use stored data). Display the transcript text with speaker labels (if available) in a readable format, and show the summary at the top or bottom. This allows users to read old transcripts. Ensure this page is protected (user should be logged in and it should fetch only their data via the auth token).                                                                                                                                                  | Frontend/UI        | P2       | A10 (transcript API), F9                      |
| **I2**  | ✓    | **CI Pipeline for Lint/Test** – Add a GitHub Actions workflow to automate quality checks. The pipeline should install dependencies and run `uv run ruff check` (lint) and `uv run mypy` (type check), as well as `uv run pytest` and `npm test`. This ensures that all code meets the standards and tests pass on every PR. Integrate this to prevent regressions.                                                                                                                                                                                                                                                                                                                                                            | Infra/CI           | P1       | —                                             |
| **D3**  | ✗    | **Update DB Documentation** – Now that the database schema and usage are implemented, update the docs: e.g. `docs/database_diagram.md` with an ER diagram of User-Meeting-Transcript relations, and describe the migration setup. Document the Meeting status enum and what each means. Ensure `README.md` or relevant docs mention the need to run Alembic migrations and how to configure `DATABASE_URL`.                                                                                                                                                                                                                                                                                                                   | Docs               | P1       | B4, S2, A8 (DB & usage done)                  |
| **D4**  | ✗    | **Document Processing Pipeline & GPU Config** – Update `docs/process_overview.md` (or create a new section) to describe the end-to-end audio processing flow: from upload, to backend processing with ASR/diarization/summarization, to storage and streaming to frontend. Include a diagram of the pipeline (FastAPI -> gRPC clients -> GPU services -> results). Also update `docs/gpu_security.md` with the mTLS certificate setup details once the repository owner provides them (where to store CA/client certs, etc). Ensure we note how to configure `GPU_TLS_*` env vars and how the TLS is validated. This will help future developers understand the integration.                                                  | Docs               | P1       | S2 (pipeline done)                            |
| **D5**  | ✗    | **Document Frontend Usage & UI** – Update documentation to cover the frontend features. For example, in `docs/README.md` or a dedicated user-guide doc, explain how a user should log in, upload an audio file, and view the transcript. Include screenshots or describe the UI components (upload form, live transcript view, meetings list). Make sure to mention any requirements (supported file format WAV, etc.). This documentation ensures the project can be used or tested by others easily.                                                                                                                                                                                                                        | Docs               | P2       | F8 (core UI done), F10 (if including history) |
| **D6**  | ✗    | **Document Auth & Security** – Update `docs/ai-context/system-integration.md` or security sections to include the authentication mechanism. Describe the JWT usage, token expiration (if any set), and how user accounts are managed (e.g. mention if it’s internal auth or placeholder for SSO). Also document any important security notes like password hashing method and the need to use HTTPS in production for JWT security, etc. This task ensures the security model is recorded for future reference.                                                                                                                                                                                                               | Docs               | P2       | A8 (auth completed)                           |

Parallel execution recommendations: Many of the above tasks can proceed in parallel to shorten development time. For example, while one agent works on the database migrations and backend auth (tasks B4, A5–A8), another can begin frontend development of the login and upload UI (F5, F7) since the API specifications for those are known. Similarly, the transcription persistence (S2) can be implemented in parallel with the latter part of auth or early UI work – it mainly depends on meetings being stored (A8). The documentation tasks (D3–D6) can be handled as each feature set is completed (or by a separate contributor in parallel, using the implemented code for reference). For instance, once the database and auth are done, D3 and D6 can be done while frontend features are being built. The CI pipeline (I2) is independent and can be set up at any time (so we start catching lint/type errors as new code is written).

Immediate priorities (P0): Finalizing the database integration and enabling authentication are top priority so that we have a persistent, secure backend. This means focusing first on Alembic migrations (B4) and the auth endpoints (A5, A6), while possibly kicking off the frontend login page (F5) concurrently. Once the foundation is in place, implement the protected routes and meeting persistence (A7, A8, S2) – these are critical path to achieve the core functionality of uploading audio and getting a saved transcript with user association. In parallel, the file upload UI (F7) can be developed (since the basic upload API exists) and the SSE display (F8) prepared to show results. By the time the backend finishes processing/storage features, the frontend should be ready to use them. This coordinated parallel approach will bring the system to a demonstrable state quickly.

Finally, regarding the research documentation: the archive is now live in `docs/researches/`, with files named `<YYYY-MM-DD>-v<version>-<short-name>.md`. The root `LATEST_RESEARCH.md` is a pointer to the newest entry, and **AGENTS.md** instructs contributors to follow that structure. Future updates should create a new dated file and refresh the pointer so that research history stays consistent and discoverable.

## Part 1 2025-09-26
Part 1 is DONE and is located in `docs/TODOS/part_001_initial.md`.

## Part 2 2025-09-27
Part 2 is IN_PROGRESS and is located in `TODO.md`

## Part 3 2025-09-27
Part 3 is IN_PROGRESS and is located in `TODO_GPU.md`

## Part 4 2025-09-27
Part 4 is POSTPONED, is waiting for Parts 2 and 3 and is located in `TODO_INTEGRATION.md`

После выполнения ВСЕХ TODO в файле, файл целиком перемещается в `docs/TODOS/part_XXX_{phase}.md`.
