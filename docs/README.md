# Documentation

Эта папка содержит актуальную документацию по сервису распознавания встреч. Здесь нужно хранить диаграммы и инструкции по использованию. При изменении архитектуры или бизнес‑процессов обновляйте соответствующие файлы.

## Диаграммы
- **database_diagram.md** – диаграмма базы данных (mermaid)
- **process_overview.md** – общая схема работы сервиса (mermaid)
- **filesystem_structure.md** – схема использования файловой системы (mermaid)
- **gpu_security.md** – варианты защиты подключения к GPU-ноде
- **ai-context/speech_stack_research.md** – результаты исследования стеков моделей и требований к GPU-сервисам
- **secure_storage_todo.md** – требования к защищённому хранилищу

## Исследования
- Каталог `docs/researches/` содержит архив подробных исследований. Каждая запись именуется по схеме `<YYYY-MM-DD>-v<версия>-<краткое-название>.md`. Актуальная ссылка всегда доступна в корневом `LATEST_RESEARCH.md`.

## Переменные окружения
Настройки приложения берутся из файла `.env`, расположенного в корне репозитория.
Укажите переменную `DATABASE_URL` для подключения к базе данных.
Переменная `DATABASE_SCHEMA_VERSION` задаёт ожидаемую версию схемы. Значение
должно совпадать с последней миграцией (например, `0.1.0`). При старте API
версия сверяется с таблицей `alembic_version`.
Параметры подключения к GPU-ноде собраны в классе `GPUSettings` и имеют префикс
`GPU_`: `GRPC_HOST`, `GRPC_PORT`, `GRPC_USE_TLS`, `GRPC_TLS_CA`,
`GRPC_TLS_CERT`, `GRPC_TLS_KEY`. Если `GPU_GRPC_USE_TLS=true`, пути к
сертификатам обязательны.

## GPU services
Для локального запуска мок-версий моделей используйте файл `infra/docker-compose.gpu.yml`.
Он поднимает контейнеры `asr`, `speaker` и `summarizer` с интерфейсом gRPC.
Все исходные аудио сохраняются во временную папку `data/raw/`. Эти файлы нужно
перенести в защищённое хранилище до конца 2025 года.

- **diarization_testing_manual.md** – пошаговая инструкция для ручного тестирования диаризации.

## Логирование и наблюдаемость
- Бэкенд использует `loguru` для структурированного JSON-логирования.
- Конфигурация находится в `app/core/logging.py` и активируется при старте приложения.
- Middleware в `app/main.py` логирует начало и завершение каждого HTTP-запроса, записывая
  метод, путь, код ответа и время обработки.

## API-маршруты
- Основные маршруты сгруппированы под префиксом `/api/meeting` (`app/api/meeting.py`).
- `POST /api/meeting/upload` — загружает WAV-файл, сохраняет его в `data/raw/` и возвращает
  `meeting_id`.
- `GET /api/meeting/{meeting_id}/stream` — отдаёт расшифровку и итоговое резюме по SSE.
- Для обратной совместимости сохранён маршрут `/stream/{meeting_id}` без префикса (legacy).

## Хранение сырого аудио
- Путь хранения задаётся через настройку `RAW_AUDIO_DIR` (см. `app/core/settings.py`).
- `TranscriptService` создаёт каталог при необходимости и работает только с файлами внутри
  него.
- Тесты могут переопределять путь, чтобы писать данные в временные директории.

## Модели и слой данных
- SQLAlchemy-модели располагаются в `app/models/` (`User`, `Meeting`, `Transcript`).
- Декларативная база и метаданные с соглашениями об именовании описаны в `app/db/base.py`.
- CRUD-репозитории находятся в `app/db/repositories/` и принимают `AsyncSession`.
- Фабрика сессий и управление кэшем реализованы в `app/db/session.py`.

## Тестовая инфраструктура
- Асинхронная SQLite-БД поднимается фикстурой `db_engine` (`backend/tests/conftest.py`).
- Каждому тесту выдаётся отдельный файл БД, схема создаётся и удаляется автоматически.
- FastAPI-зависимости для БД переопределяются через `dependency_overrides`, что позволяет
  запускать API-тесты с временной БД.
- Для gRPC-клиентов используются фикстуры JSON с моковыми ответами (`backend/tests/fixtures/`).

### Потоковая передача аудио

При обращении к GPU-сервисам аудио передаётся в виде итератора байтов (`Iterable[bytes]`).
`MeetingProcessingService` для каждого gRPC-клиента повторно открывает `.wav`-файл и
отдаёт независимый генератор, читающий данные порциями по умолчанию по 64 КБ.
Реальные клиенты должны полностью итерировать переданный поток, чтобы гарантированно
прочитать файл и обнаружить ошибки чтения. Такой же контракт необходимо соблюдать и в
других сервисах (диаризация, voice activity detection), чтобы обеспечить единый
интерфейс интеграции с GPU.

## PostgreSQL
Для разработки поднимите локальную базу данных командой:

```bash
docker compose -f infra/docker-compose.dev.yml up -d postgres
```

В CI используйте облегчённую конфигурацию:

```bash
docker compose -f infra/docker-compose.ci.yml up -d postgres
```

Обе конфигурации создают базу `voicerec` с пользователем `voicerec` и включённым healthcheck на основе `pg_isready`.

## Компиляция proto-файлов
Для генерации Python-модулей воспользуйтесь пакетом `grpcio-tools`. Запустите команду:

```bash
python -m grpc_tools.protoc -I ./protos --python_out=./backend/app/protos --grpc_python_out=./backend/app/protos ./protos/*.proto
```

При необходимости создайте папку `backend/app/protos`. В ней появятся файлы `*_pb2.py` и `*_pb2_grpc.py`, которые затем можно импортировать в коде.
