# TODO

Отмечайте прогресс в колонке **DONE**: пока задача не выполнена, ставьте «✗», после завершения замените на «✓».

## Part 4 2025-09-28

Зависимости - Part 2, Part 3.

Теперь, когда определены задачи по созданию самих сервисов, необходимо спланировать интеграцию их с основным приложением (FastAPI бэкендом) и фронтендом. Эти задачи охватывают изменения конфигурации, оркестрацию, пост-обработку результатов и обновление пользовательского опыта (например, отображение говорящих). Итоговый список оформлен как отдельный TODO_INTEGRATION.md.

**Цели интеграции:** - Переключить Backend с mock-клиентов на реальные gRPC вызовы. - Обеспечить доступность GPU-сервисов (настройка адресов, безопасность). - Обработать новые данные (например, сегменты диаризации) - возможно, сохранять их и использовать на фронтенде. - Улучшить выдачу для пользователя: имена говорящих в тексте, и т.д. - Оставить возможность работать в режиме разработки без GPU (т.е. fallback на mock).

Приоритеты интеграционных задач также размечены: P0 для критически необходимых, P1 для важных улучшений, P2/P3 для дальнейших шагов.

| ID       | DONE | Task (Описание задачи)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Area                    | Priority | Dependencies                                  |
| -------- | ---- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------- | -------- | --------------------------------------------- |
| **I3**   | ✗    | **Переключение бекенда на реальные GPU-сервисы** – *Разбито на подзадачи I3_x ниже*. Изменить бекенд (FastAPI) так, чтобы он вызывал gRPC API новых сервисов вместо мок-реализаций.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Backend/GPU Integration | P0       | G1, G2, G3 (сервисы запущены)                 |
| **I3_1** | ✗    | **Настройки подключения к нескольким сервисам** – Обновить класс настроек `GPUSettings` в бекенде. Сейчас он имеет `GPU_GRPC_HOST` и единый `GPU_GRPC_PORT`. Добавить отдельные поля для портов (и при необходимости хостов) каждого сервиса: например, `ASR_GRPC_PORT`, `DIAR_GRPC_PORT`, `SUMM_GRPC_PORT` (если хост общий, достаточно одного `GPU_GRPC_HOST`). Прописать эти переменные в `.env.example` с значениями по умолчанию (например, 50051/50052/50053). Если принято решение держать один порт с unified-сервером, то можно альтернативно поддержать оба режима (например, если `GPU_SINGLE_PROCESS=true`, использовать `GPU_GRPC_PORT`, иначе – отдельные).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Backend/Config          | P0       | .env, G4 (решение о портах)                   |
| **I3_2** | ✗    | **Фабрика gRPC-клиентов с раздельными адресами** – Модифицировать фабричную функцию `create_grpc_client` в бекенде (в модуле `app/grpc_client.py` или `app/clients/grpc_clients.py`). Ранее она, вероятно, смотрит на `GPUSettings` и создает либо MockClients, либо реальные gRPC Stubs. Теперь нужно учесть несколько сервисов: в зависимости от типа клиента (`transcribe`, `diarize`, `summarize`) подключаться на разные порты. Например, можно в `GPUSettings` добавить метод или свойство, возвращающее порт по имени сервиса, или в самой функции сделать if/elif. Реализовать создание `grpc.Channel` на `GPU_GRPC_HOST:ASR_GRPC_PORT` для ASR (и аналогично для других), затем возвращать сгенерированный Stub (например, `TranscribeStub(channel)` и т.д.). Убедиться, что при инициализации приложения создаются клиенты для всех сервисов (или по требованию) и что они используют правильные адреса.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Backend                 | P0       | I3_1 (настройки готовы)                       |
| **I3_3** | ✗    | **Переключение с mock на grpc** – Изменить конфигурацию по умолчанию, чтобы приложение использовало реальный режим. Вероятно, в `pipeline.py` или в `settings` есть параметр типа `GRPC_CLIENT_TYPE` = 'mock' сейчас. Переключить на 'grpc' по умолчанию для боевого запуска. При этом обеспечить, что можно обратно переключиться на mock (например, для тестов) – то есть не удалить mock-клиенты совсем. Простым способом: оставить переменную, но в `.env.example` выставить 'grpc'. Протестировать запуск бекенда: он должен пытаться подключаться к указанным gRPC сервисам (если они не запущены – будет ошибка соединения, это нормально на этапе разработки). Убедиться, что при запущенных контейнерах (из G4_3) backend успешно вызывает методы (можно временно добавить логи или использованные порты в вывод для уверенности).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Backend                 | P0       | I3_2 (клиенты реализованы)                    |
| **I3_4** | ✗    | **Обеспечение режима без GPU (fallback)** – Позаботиться, чтобы система могла работать **без** запущенных GPU-сервисов (например, в тестовой среде CI/CD). Для этого убедиться, что переменная `GRPC_CLIENT_TYPE=mock` продолжает переключать клиентов на mock-объекты. Проверить, что ни одна из вышевыполненных модификаций не сломала режим mock: запустить тесты бекенда, они должны проходить (там, где используем MockTranscribeClient и пр.). Возможно, имеет смысл в коде `create_grpc_client` сделать так, что при отсутствии указанных GPU_HOST/портов или при явном указании типа 'mock' – используются моки. Таким образом, разработка и тестирование могут выполняться без поднятия тяжелых сервисов.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Backend                 | P0       | I3_2                                          |
| **I4**   | ✗    | **Общий доступ к аудиофайлам** – Настроить единое хранилище аудио между backend и GPU-сервисами. Локально (в Docker Compose) это уже учтено (том `data/raw` смонтирован в контейнеры). Необходимо проверить в конфигурации бекенда путь сохранения загруженных файлов. Например, бекенд сохраняет файл в `data/raw/<name>.wav` (см. `RAW_AUDIO_DIR` в настройках). Убедиться, что в контейнерах GPU-сервисов этот путь соответствует тому же самому физическому файлу (благодаря общему тому). Если есть рассогласование (например, бекенд сохраняет вне `/app/data`), исправить либо путь сохранения, либо путь монтирования. В `.env` задать `RAW_AUDIO_DIR=/app/data/raw` (путь внутри контейнера). **В продакшене**, где сервисы могут быть на разных машинах, предусмотреть использование общего хранилища: например, NAS или S3. Это выходит за рамки разработки, но в документации отметить: *GPU-сервисы должны иметь доступ к тем же аудиофайлам, что и бекенд*.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Infra/Storage           | P0       | deployment env, G1-G3                         |
| **I5**   | ✗    | **Безопасное соединение (TLS/mTLS) между сервисами** – *Разбито на I5_x ниже*. Обеспечить шифрование трафика gRPC между бекендом и GPU-сервисами, согласно требованиям безопасности.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Backend/GPU Security    | P1       | G1-G4, I3 (базовая работа)                    |
| **I5_1** | ✗    | **Генерация сертификатов** – Создать самоподписанные сертификаты для gRPC-сервисов. Для mTLS нужны: сертификат и приватный ключ сервера, сертификат и ключ клиента, а также CA (можно сам CA выступать одновременно сервером). Сгенерировать (с помощью openssl или скрипта) файлы, например: `gpu_server.crt` + `gpu_server.key` для сервисов, `client.crt` + `client.key` для бекенда, и `ca.crt` (общий корневой). Разместить эти файлы (в dev-режиме) в каталоге `certs/` и добавить их в `docker-compose.gpu.yml` как volume (чтобы сервисы могли их прочитать).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Security                | P1       | (внешние инструменты)                         |
| **I5_2** | ✗    | **Настройка TLS на стороне GPU-сервисов** – Изменить код запуска gRPC-серверов (в сервисах ASR, Diarize, Summarize): при создании `grpc.Server()` использовать SSL-сертификат. Например, загрузить `gpu_server.crt` и `gpu_server.key`, вызвать `grpc.ssl_server_credentials(((key, cert),))` и передать в `server.add_secure_port('0.0.0.0:50051', creds)`. Если нужна проверка клиента (mTLS), передать также `request_client_certificate=True` и CA-корень. Убедиться, что сервисы запускаются без ошибок с включенным TLS (в логах может быть пометка о secure connection). В `.env` ввести флаг `GPU_GRPC_USE_TLS=true/false` – чтобы легко переключать режим. При false – сервер запускается обычным `add_insecure_port`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | GPU Services            | P1       | I5_1 (сертификаты готовы)                     |
| **I5_3** | ✗    | **Настройка TLS на стороне бекенда** – Обновить gRPC-клиенты в бекенде: при создании канала использовать secure_channel с загрузкой сертификатов. В `GPUSettings` уже предусмотрены поля `GPU_GRPC_TLS_CA`, `GPU_GRPC_TLS_CERT`, `GPU_GRPC_TLS_KEY` – заполнить их путями (в .env) до соответствующих файлов (например, внутри контейнера бекенда они тоже будут смонтированы). В коде `create_grpc_client`, при `use_tls=true` создать креденшилы: `grpc.ssl_channel_credentials(ca_cert, client_cert, client_key)` и передавать их в `grpc.secure_channel(host:port, creds)`. Протестировать локально: запустить compose с TLS включенным (в .env `GPU_GRPC_USE_TLS=true` и заданы пути к файлам сертификатов в контейнерах). Бекенд должен успешно подключиться (если нет – смотреть ошибки TLS handshake в логах).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Backend Security        | P1       | I5_2 (сервисы с TLS)                          |
| **I5_4** | ✗    | **Вариант через VPN** – (Опционально) Если предполагается вместо mTLS использовать VPN-туннель, убедиться, что при `GPU_GRPC_USE_TLS=false` система работает по нешифрованному каналу внутри VPN. В документации (`docs/gpu_security.md`) описать оба подхода: что по умолчанию можно прокинуть соединение через VPN, тогда ничего не надо менять в коде, или включить mTLS как выше. Пошагово расписать, как сгенерировать сертификаты и какие переменные выставить.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Infra/Security Docs     | P1       | I5_3                                          |
| **I5_5** | ✗    | **Тестирование безопасного режима** – После настройки TLS, провести тест: поднять сервисы и бекенд с включенным TLS, выполнить загрузку файла и получение расшифровки. Убедиться, что все работает так же, как раньше, и в логах трафик шифруется (явных признаков может не быть, но отсутствие ошибок handshake – уже признак). Также проверить, что при неверных сертификатах соединение не устанавливается (например, указать неправильный client cert – бекенд должен не подключиться). После этого считать безопасное соединение настроенным.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Tests/Security          | P1       | I5_3, I5_4                                    |
| **I6**   | ✗    | **Сохранение и выдача меток говорящих** – *Разбито на подзадачи I6_x ниже*. Интегрировать результаты диаризации в базу данных и в API, чтобы фронтенд мог отображать, кто говорит в каждой части транскрипта.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Backend/API & DB        | P1       | S2 (сохранение транскриптов), G2 (диаризация) |
| **I6_1** | ✗    | **Модификация схемы БД для спикеров** – Проверить модель `Transcript` в базе. Если в модели/миграциях нет поля для указания говорящего, добавить его. Например, добавить колонку `speaker_label VARCHAR` в таблицу transcripts (или числовой speaker_id с отдельной таблицей Speakers – но для упрощения можно строковый ярлык). Использовать Alembic: создать новую миграцию, добавляющую поле `speaker_label` (по умолчанию NULL или 'Speaker 1' для существующих записей). Применить миграцию в локальной БД. Обновить SQLAlchemy модель `Transcript` соответственно.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Backend/DB              | P1       | B4 (базовая миграция)                         |
| **I6_2** | ✗    | **Сопоставление сегментов с говорящими** – В серверной логике обработки (класс `TranscriptService` или `MeetingProcessingService.process`) реализовать объединение результатов ASR и диаризации. У нас есть список сегментов текста (с таймстампами) от Whisper и список сегментов говорящих (с временными интервалами) от диаризации. Реализовать алгоритм: для каждого текстового сегмента определить, какому говорящему он принадлежит. Простой подход – взять временную середину сегмента текста (midpoint = (start+end)/2) и найти в списке диаризации тот сегмент, чьи времена охватывают эту точку (speaker_segment.start <= midpoint <= speaker_segment.end). Назначить текстовому сегменту метку соответствующего спикера. Если сегменты не пересекаются идеально, можно использовать начало текста: если начало текста falls между start-end говорящего, прикрепить его. Для коротких реплик это достаточно точно. Если диаризация вернула только одного говорящего, всем сегментам назначить "Speaker 1".                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Backend/Logic           | P1       | G2 (результаты диаризации)                    |
| **I6_3** | ✗    | **Сохранение транскриптов с говорящими** – После сопоставления, сохранить расшифровку в базу уже с указанием спикеров. В реализации сохранения (Task S2: Persist Transcription Results) нужно при создании каждой записи Transcript задавать поле speaker_label. Обновить соответствующий код (в `TranscriptRepository` или прямо в сервисе, где вызывается репозиторий). Убедиться, что при сохранении каждого сегмента текста теперь сохраняется и колонка speaker_label. При обновлении Meeting статус пометить как завершенный, как и планировалось.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Backend/DB              | P1       | I6_1, I6_2 (спикер определен)                 |
| **I6_4** | ✗    | **Формат ответа API** – Обновить эндпоинт получения деталей встречи `GET /api/meeting/{id}` (Task A10). Ранее он мог возвращать либо цельный текст транскрипта, либо список сегментов (текстовых) – нужно убедиться, что теперь он возвращает вместе с говорящими. Предпочтительно вернуть список объектов, например: `{speaker: "Speaker 1", text: "фраза", start: 0.0, end: 5.2}` для каждого сегмента. Если в текущей реализации `/meeting/{id}` просто отдаёт конкатенированный текст, переработать его: пусть собирает сегменты из TranscriptRepository и формирует JSON-массив сегментов. Добавить поле speaker в эту структуру. Аналогично, если есть отдельное поле summary (сводка) – добавить его в ответ (можно под ключом `summary`). Обновить описание этого эндпоинта в документации, если имеется.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Backend/API             | P1       | I6_3 (данные сохраняются)                     |
| **I6_5** | ✗    | **Обработка SSE (онлайн режим)** – (Опционально, можно упрощенно) Подумать, как передавать метки спикеров в реальном времени через SSE `/stream`. Сейчас SSE события, вероятно, реализованы как: по мере готовности сегмента Whisper отправляется событие `transcript` с текстом. Диаризация же завершится только после полного аудио. В реальном времени трудно сразу метить спикеров. Можно оставить SSE как есть (он отдает текст без спикеров во время обработки), а после завершения (последнего события) фронтенд сделает запрос на полный транскрипт с говорящими. Либо можно по завершении диаризации отправить отдельное событие, например `diarization` с массивом {start, end, speaker} сегментов – и на фронте попытаться сопоставить. Но это сложно синхронизировать. Более простой путь: **сделать фронт запрашиваемым итоговые данные**. Поэтому можно ограничиться тем, что SSE во время обработки не содержит спикеров, а финальный API (из I6_4) их предоставляет. В коде это означает, что можно не трогать логику SSE (кроме, может быть, добавления события `summary`).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Backend/SSE             | P2       | I6_4 (спикеры в данных)                       |
| **I6_6** | ✗    | **Тестирование функции спикеров** – Провести тестирование полного процесса с диаризацией: загрузить аудио с 2+ участниками, дождаться окончания обработки. Затем вызвать GET `/api/meeting/{id}` и проверить, что в ответе сегменты помечены разными `speaker`. Убедиться, что данные в базе сохранены правильно (можно посмотреть напрямую в таблице transcripts). Также проверить, что если аудио с одним говорящим – все сегменты имеют "Speaker 1". И что фронтенд (если уже обновлен в I7) корректно отображает эти метки.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Tests                   | P1       | I6_4, I7 (если UI готов)                      |
| **I7**   | ✗    | **UI: Отображение говорящих на фронтенде** – *Разбито на I7_x ниже*. Обновить интерфейс пользователя, чтобы он показывал, кто произнес каждую часть текста.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Frontend/UI             | P2       | I6 (бекенд отдает спикеров)                   |
| **I7_1** | ✗    | **Transcript Detail с метками** – В компоненте **TranscriptDetail** (страница расшифровки встречи) изменить вывод текста. Ранее он, возможно, показывал цельный текст или список абзацев. Теперь, получая от API массив `{speaker, text, ...}`, отрисовывать их с указанием говорящего. Например: перед текстом каждого сегмента вставить `<b>{speaker}:</b> ` и затем сам текст. Можно стилизовать: каждому уникальному спикеру присвоить свой цвет текста или метку (например, с разными аватарками, но для простоты – цвет/значок). Убедиться, что при рендеринге сохраняется порядок сегментов. Если реализовано событие summary, отобразить резюме отдельным блоком (например, вверху или внизу транскрипта, с заголовком "Summary").                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Frontend/UI             | P2       | I6_4 (API данных готов)                       |
| **I7_2** | ✗    | **Список встреч: участники** – На странице списка встреч (Task F9) добавить информацию о количестве спикеров или именах. Например, в каждой строке списка показывать "Спикеры: 2" если в записи больше одного говорящего. Эти данные можно получить, например, подсчитав уникальные speaker_label в транскриптах встречи (можно хранить это число в таблице Meeting, но проще – на фронте после получения деталей). Поскольку API списка встреч (A9) пока не отдаёт спикеров, можно реализовать следующим образом: при клике на встречу на Detail странице все равно увидим подробности. Поэтому этот пункт не критичен – основное, отобразить в деталях. (Опционально: улучшить API списка, чтобы он возвращал, скажем, поле `speaker_count` или список спикеров, тогда фронт сможет сразу показать).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Frontend/UI             | P3       | A9, I6 (данные о спикерах)                    |
| **I7_3** | ✗    | **Live UI без изменений** – Принять решение насчет отображения говорящих в **режиме реального времени** (SSE поток, компонент F8). Как обсуждалось, метки спикеров в момент стриминга достоверно недоступны. Вероятно, на Phase 1 можно оставить как есть: в реальном времени отображаются сегменты текста слитно. После завершения пользователь может обновить страницу или перейти в детальный просмотр, где уже будет расшифровка с разделением по спикерам. В качестве улучшения можно в live-транскрипте при приходе финального события (summary) либо по таймеру автоматически перезагрузить данные встречи (вызвать API /meeting/{id}) и обновить отображение на разделе деталей. Но это сложнее, можно сделать позже. Поэтому на этапе Phase 2 фронтенд **в live режиме спикеров не показывает**, только в итоговом. В документации/подсказках можно указать это ограничение.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Frontend/SSE            | P3       | I6 (понимание ограничения)                    |
| **I7_4** | ✗    | **Локализация** – При добавлении интерфейсных элементов проверить, не нужны ли новые строки перевода. Например, слово "Speaker" на русском "Спикер". Если использована маркировка "Speaker 1, Speaker 2", можно оставить на английском или перевести. Убедиться, что все новые тексты (например, метка "Summary" если добавлена) вынесены в файлы локализации en/ru и используются через i18n.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Frontend/I18n           | P3       | I7_1 (UI изменен)                             |
| **I7_5** | ✗    | **Тестирование интерфейса** – Протестировать фронтенд с обновлениями: загрузить аудио через UI, дождаться вывода. Убедиться, что на странице **Live Transcript** текст идет без спикеров (как ожидалось), после завершения отображается резюме (если реализовано). Затем открыть эту встречу в **Transcript Detail** – проверить, что перед каждым сегментом стоит правильный спикер (Speaker 1/2/etc.), сегменты разделены корректно, цвета/стили применяются. Проверить на разных сценариях: файл с одним говорящим (должен отображаться только Speaker 1), с несколькими, на английском языке (метки спикеров все равно "Speaker X"). Убедиться, что ничего не ломается (например, длинные имена спикеров или много сегментов не рушат верстку).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Frontend/Test           | P2       | I7_1 (функционал готов)                       |
| **I8**   | ✗    | **End-to-End тестирование и оптимизация** – После интеграции всех компонентов провести сквозной тест на реалистичных данных и при необходимости оптимизировать. Взять длительную аудиозапись встречи (например, 5-10 минут, 2-3 спикера). Загрузить через фронтенд, проследить полный процесс: распознавание (ASR) -> диаризация -> суммаризация -> отображение. Измерить время выполнения каждого этапа и общее время. Если возможно, включить логирование времени в код (например, ASR занял X секунд, диаризация Y, суммирование Z). Оценить производительность: для 10 мин аудио приемлемо, если обработка занимает ~2-3 минуты (реальное время). Если значительно дольше, определить узкие места. Возможные проблемы: **ASR Whisper Large** – самый медленный (близко к х1 реального времени на GPU). Диаризация NeMo обычно быстрее (~0.5x). Суммаризация зависит от длины текста, но обычно несколько секунд. Если ASR слишком медленный, рассмотреть варианты оптимизации: например, использовать модель поменьше (Whisper Medium) ценой точности – можно сделать это на уровне конфигурации (поменяв `ASR_MODEL_SIZE` и перезапустив сервис) и сравнить качество/скорость. Или если доступно несколько GPU – параллельно обрабатывать несколько кусков (реализация сложна). В рамках этой задачи: зафиксировать текущие показатели и обсудить с командой, устраивают ли они. Если есть простые оптимизации (например, увеличить размер chunk в Whisper или отключить ненужные опции) – внести и измерить снова. Конечная цель – убедиться, что система стабильно обрабатывает данные конечной длины, а вывод корректен (текст точный, спикеры правильные, резюме осмысленное). Результаты этого тестирования описать (в виде комментария в документации или отдельного отчета), чтобы иметь референс производительности. | System/Test             | P1       | I3-I7 (вся функциональность)                  |
| **I9**   | ✗    | **План реализации стримингового распознавания** – *Аналитическая задача на будущее*. Описать, какие шаги необходимы для поддержки **потокового ASR в реальном времени** (когда аудио идет непрерывно с микрофона, а текст появляется сразу). Изучить варианты: модель **Whisper** можно заставить работать на стрим (передавая кусочки с overlap), либо интегрировать специализированную систему (**NVIDIA Riva** ASR с realtime, или другие модели). На базе выбранной технологии описать изменения: 1) На фронтенде – использовать WebSocket или WebRTC для передачи аудио чанками, вместо загрузки файла. 2) На бекенде – endpoint, который принимает аудиопоток и порционно отправляет в ASR сервис (в gRPC тоже понадобится стриминг RPC вместо unary). 3) Модификация ASR сервиса – принимать поток аудио и выдавать частичные результаты (это самая сложная часть, Whisper изначально не стримовый, но можно запускать каждые N секунд на накопленном буфере с пересечением). Продумать, как синхронизовать вывод, чтобы не было дублей и пропусков. Также учесть, как диаризация будет работать в стриминговом режиме (возможно, пост-фактум или с задержкой). Все эти моменты собрать в документе (создать `docs/researches/streaming_plan.md`). Пока что реализацию не выполнять, только план: оценить трудоемкость, требования к инфраструктуре (например, возможно, понадобится более быстрая модель ASR для стрима). Этот план позволит взвесить, стоит ли браться за стриминг в следующих фазах.                                                                                                                                                                                                                                                                                                                    | Research/Future         | P3       | (нет прямых зависимостей)                     |

Примечание: После выполнения вышеперечисленных задач система завершит Фазу 2 (реализация реальной обработки аудио на GPU). Все аудио будут обрабатываться реальными моделями, результаты сохраняться, фронтенд отображать говорящих. Далее можно переходить к Фазе 3 (улучшения UI, дополнительные фичи), уже имея надежно работающий функционал распознавания.

## Part 1 2025-09-26
Part 1 is DONE and is located in `docs/TODOS/part_001_initial.md`.

## Part 2 2025-09-27
Part 2 is IN_PROGRESS and is located in `TODO.md`

## Part 3 2025-09-27
Part 3 is IN_PROGRESS and is located in `TODO_GPU.md`

## Part 4 2025-09-27
Part 4 is POSTPONED, is waiting for Parts 2 and 3 and is located in `TODO_INTEGRATION.md`

После выполнения TODOшки перемещаются в `docs/TODOS/part_XXX_{phase}.md`.
